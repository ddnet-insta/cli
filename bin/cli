#!/usr/bin/env ruby

require_relative "ddnet-insta-cli/lib/strings"

# comments use YARD format
# https://rubydoc.info/gems/yard/file/docs/GettingStarted.md

class Controller
  @@pvp_controller = nil

  attr_reader :path

  def initialize(opts = {})
    # relative path from
    # src/game/server/gamemodes/
    @path = opts[:path] || ["instagib"]

    # class name
    @name = opts[:name].to_camel
    raise "Name can not be empty!" if @name.empty?

    # [String] filename base without extension
    @filename = opts[:filename].to_snake
    raise "Filename can not be empty!" if @filename.nil? || @filename.empty?
    raise "Invalid filename: #{@filename}" if @filename.include? '.'
  end

  # camel cased name
  def name
    @name
  end

  def class_name
    "CGameController#{@name}"
  end

  def name_snake
    @name.to_snake
  end

  # @return [String] controller header filename
  def header_filename
    "#{name_snake}.h"
  end

  # @return [String] controller cpp source filename
  def source_filename
    "#{name_snake}.cpp"
  end

  def self.pvp
    return @@pvp_controller if @@pvp_controller

    # TODO: omg all these values are so close!!!
    #       change the C++ code so we can do convention
    #       over configuration
    @@pvp_controller = Controller.new(
      path: 'base_pvp',
      name: 'pvp',
      filename: 'base_pvp',
    )
  end

  # TODO: create user facing dropdown with this
  #       so we can pick a parent controller
  def self.list
    {
      pvp: {
        controller: self.pvp,
        description: 'Basic pvp controller. Top recommendation!'
      }
    }
  end
end

class Gamemode
  def initialize(opts = {})
    opts[:filename] = opts[:name] if opts[:filename].nil?
    @controller = Controller.new(opts)

    # camel name of parent controller
    @parent_controller = Controller.pvp
  end

  # @return [String] gamemode.h C++ source code
  def gen_cpp_header
    [
      include_guard_open,
      "",
      '#include "../base_pvp/base_pvp.h"',
      "",
      "class #{@controller.class_name} : public #{@parent_controller.class_name}",
      "{",
      "public:",
      "	#{@controller.class_name}(CGameContext *pGameServer);",
      "	~#{@controller.class_name}() override;",
      "",
      header_methods,
      "};",
      include_guard_close
    ].join("\n") + "\n"
  end

  # @return [String] gamemode.cpp C++ source code
  def gen_cpp_source
    [
      "#include \"#{@controller.header_filename}\"",
      "",
      "#include <game/server/entities/character.h>",
      "#include <game/server/gamecontext.h>",
      "#include <game/server/player.h>",
      "",
      "#{@controller.class_name}::#{@controller.class_name}(CGameContext *pGameServer) :",
      "	#{@parent_controller.class_name}(pGameServer)",
      "{",
      constructor_body,
      "}",
      "",
      "#{@controller.class_name}::~#{@controller.class_name}() = default;",
      "",
      source_methods,
      "",
      "REGISTER_GAMEMODE(#{@controller.name_snake}, #{@controller.class_name}(pGameServer));"
    ].join("\n") + "\n"
  end

  private

  def constructor_body
    [
      "// if you do not need team red/blue or the red and blue flag from ctf",
      "// just do m_GameFlags = 0;",
      "m_GameFlags = GAMEFLAG_TEAMS | GAMEFLAG_FLAGS;",
      "m_pGameType = \"#{@controller.name_snake}\"",
      "m_DefaultWeapon = WEAPON_GUN;",
      "",
      "m_pStatsTable = \"#{@controller.name_snake}\"",
      "m_pExtraColumns = new C#{@controller.name}Columns();",
      "m_pSqlStats->SetExtraColumns(m_pExtraColumns);",
      "m_pSqlStats->CreateTable(m_pStatsTable);",
    ].map { |m| "\t#{m}" }.join("\n")
  end

  def include_guard_open
    slug = @controller.path.map(&:upcase).join('_')
    slug += '_' unless slug.empty?
    slug += @controller.name.to_snake.upcase
    [
      "#ifndef GAME_SERVER_GAMEMODES_#{slug}_H",
      "#define GAME_SERVER_GAMEMODES_#{slug}_H",
    ].join("\n")
  end

  def include_guard_close
    "#endif"
  end


  def source_methods
    # TODO: the header and source methods should be be kept in sync with some kind of data structure
    #       that matches methods by name
    #       and then writes the correct signatures
    #       and these signatures should be fetched from the source code
    #       not hardcodet in here
    [
      "// TODO: add methods here, but they should be dynamic"
    ].join("\n")
  end

  def header_methods
    [
      "void OnInit() override",
      "int OnCharacterDeath(class CCharacter *pVictim, class CPlayer *pKiller, int Weapon) override;",
    ].map { |m| "\t#{m}" }.join("\n")
  end
end

class Cli
  def initialize
    mode = Gamemode.new(
      name: 'placeholder'
    )
    puts mode.gen_cpp_source
  end
end

cli = Cli.new
